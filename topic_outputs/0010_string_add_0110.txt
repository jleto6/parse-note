00101100 0010 Shifts 3 1 00001011 00101100 0010 Test-no add 3 2,3 00001011 01011000 0001 Shifts 4 1a. 01100011 01011000 0001 Add 4 2,3 01100011 10110000 0000 Shifts Multiplication is Time Consuming • 3 steps per iteration • 32 iterations • 96 steps total Observations on Multiplication Version 1 •

---

1110 1011 Test-no add 3 2 0001 0111 1011 Shift 4 1a. 1100 0111 1011 Add 4 2 0110 0011 1011 Shift Note: Multiplier in Product Register is underlined Multiplying by a Constant • Some compilers replace multiplies by short constants with a series of shifts and adds. Because one

---

Algorithm • Example: 2 x 6 = 0010 x 0110: 0010 x 0110 + 0000 shift (0 in multiplier) + 0010 add (1 in multiplier) + 0010 add (1 in multiplier) + 0000 shift (0 in multiplier) 00001100 • ALU can get same result in more than one way: •

---

first 1 (from right) • later, add when we see 0 at left end of the string of 1s. • Example 0010 x 0110 + 0000 shift (0 in multiplier) - 0010 subtract (first 1 in string) + 0000 shift (within string of 1s) + 0010 add (end of string)

---

string: Subtract => Add 0110 1 2 0011 010(1 1) 1 Shift arithmetic 2 1.11 0011 010(1 1) 1 Middle string: nothing 2 2 0001 101(0 1) 1 Shift arithmetic 3 1.01 1011 101(0 1) 1 End string: add 1010 3 2 1101 110(1 0) 0 Shift arithmetic 4 1.10