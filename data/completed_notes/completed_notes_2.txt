<h1>Circuit System Types and Canonical Boolean Representations</h1>
<p style="color:whitesmoke;">
<strong>Combinational</strong> and <strong>Sequential circuits</strong> are two fundamental forms of digital logic systems. Understanding the distinction between them underpins more advanced concepts such as finite state machines and processor design, as well as the implementation and optimization of Boolean functions critical to digital hardware design.
</p>
<!-- END_SECTION -->

<h3>Combinational vs Sequential Circuits</h3>
<p style="color:whitesmoke;">
A <strong>combinational circuit</strong> is a type of digital logic circuit whose output is a pure function of the present input values. This means that, at any given instant of time, the outputs depend only on the current inputs, with no dependence on previous input states or outputs. Typical examples include <strong>adders</strong>, <strong>multiplexers</strong>, <strong>decoders</strong>, and arbitrary logic implemented from Boolean equations.
</p>
<p style="color:whitesmoke;">
By contrast, a <strong>sequential circuit</strong> is characterized by its dependence on both current inputs and past history. The circuit "remembers" prior states via internal storage elements (most often flip-flops or latches), and thus its output may vary depending on the history of the inputs as well as their present values. This inherent "memory" property enables construction of devices such as registers, counters, and all forms of finite state machines.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
The distinction matters because <strong>combinational logic</strong> is stateless and determined by Boolean algebraic manipulation—critical for arithmetic circuits and digital signal processing—while <strong>sequential logic</strong> forms the basis for memory and stateful control in complex electronics such as CPUs and microcontrollers.
</p>
<p style="color:whitesmoke;">
Block diagrams are frequently used to illustrate the structure of these circuit types. In <strong>combinational block diagrams</strong>, connections run directly from inputs through logic gates to outputs, while in <strong>sequential block diagrams</strong>, one observes a feedback loop involving storage elements and potentially a synchronizing clock signal.
</p>
<!-- END_SECTION -->

<h3>Logic Gates and Boolean Canonical Forms</h3>
<p style="color:whitesmoke;">
<strong>Logic gates</strong> are the elementary building blocks of digital circuits, performing basic Boolean operations such as AND, OR, NOT, NAND, NOR, XOR, and XNOR. These gates are implemented electrically (e.g., with transistors, diodes, and resistors) and, when connected together, can realize complex functions described by Boolean algebra.
</p>
<p style="color:whitesmoke;">
A key task in engineering these circuits is expressing Boolean functions in <strong>canonical forms</strong>. <strong>Canonical forms</strong> are standardized algebraic expressions that explicitly enumerate the conditions under which a circuit produces a '1' (output true) or a '0' (output false). The two principal canonical forms are <strong>Sum of Products (SOP)</strong> and <strong>Product of Sums (POS)</strong>.
</p>
<p style="color:whitesmoke;">
<ul>
  <li>
    <strong>Sum of Products (SOP)</strong> is constructed from <strong>minterms</strong>. Each minterm corresponds to a row in the truth table where the function outputs <strong>1</strong>. Each such row produces an <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">AND</code> term over all inputs, using the complemented variable when the truth table input is 0. All minterm terms are then combined through <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">OR</code>.
  </li>
  <li>
    <strong>Product of Sums (POS)</strong> is built from <strong>maxterms</strong>. Each maxterm corresponds to a row in the truth table where the function outputs <strong>0</strong>. Each such row results in an <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">OR</code> term, with each input variable complemented if its truth table entry is 1. All maxterm terms are then combined through <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">AND</code>.
  </li>
</ul>
</p>
<p style="color:whitesmoke;">
For example, consider a function F of three variables A, B, and C. If F is true when <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">A=0, B=1, C=0</code>, the corresponding <strong>minterm</strong> (for SOP) is <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">A' B C'</code>. If F is false when <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">A=1, B=0, C=1</code>, the corresponding <strong>maxterm</strong> (for POS) is <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">A' + B + C</code>.
</p>
<p style="color:whitesmoke;">
Expressing logic in canonical forms directly determines the circuit implementation: for SOP, this means <strong>AND</strong> gates feeding into a single <strong>OR</strong> gate, and for POS, <strong>OR</strong> gates feeding into a single <strong>AND</strong> gate.
</p>
<!-- END_SECTION -->