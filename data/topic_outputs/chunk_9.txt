dryer, and start a new load (load C) in the 
washer.
4.
When folding is finished, put away load A, fold load B, place load 
C in the dryer, start load D in the washer.

Analogy for Pipelining: Laundry

Pipelining Paradox
• One load of laundry still takes the same amount of time.
• The amount of time it takes to do many loads of laundry is 
shorter with pipelining.
• Pipelining improves throughput.

Pipelining Speedup
• If all the stages take about the same amount of time and 
there is enough work to do, then the speedup due to 
pipelining is roughly equal to the number of stages in the 
pipeline.
• Laundry Analogy: 
• 4 stages (washing, drying, folding, putting away)
• 20 loads pipelined would take about 5 times as long as 1 load
• 20 loads of sequential laundry takes 20 times as long as 1 load

MIPS Pipeline
1.
Fetch instruction from 
memory.
1.
Read registers while 
decoding the instruction. 
1.
Execute the operation or 
calculate an address.
1.
Access an operand in data 
memory.
1.
Write the result into a register.
• Instruction Fetch
(IF)
• Instruction Decode
(ID)
• Execution
(EX)
• Memory Access
(MEM)
• Write Back
(WB)

Pipeline Speedup
• If all stages are balanced
• i.e., all take the same time
• Time between instructionspipelined
=
Time between instructionsnonpipelined
Number of stages
• If not balanced, speedup is less
• Speedup due to increased throughput
• Latency (time for each instruction) does not decrease
• Programs execute billions of instructions – throughput is important!

Pipelining and ISA Design
• MIPS ISA designed for pipelining
• All instructions are 32-bits
• Easier to fetch and decode
• Few and regular instruction formats
• Can decode and read registers in one step
• Load/store addressing
• Can calculate address in 3rd stage, access memory in 4th stage
• Alignment of memory operands
• Memory access takes only one cycle

MIPS Pipelined Datapath
WB
Branch

Pipelined Execution

Pipeline registers
• Need registers between stages
• To hold information produced in previous cycle

IF for Load

ID for Load

EX for Load

MEM for Load

WB for Load
Wrong
register
number

Corrected Datapath for Load

Pipelined Control

Pipelined Control
•
Instruction fetch: 
•
PC written on every clock cycle
•
Instruction memory read on every clock cycle
•
no optional control lines
•
Instruction decode/register file read
•
Register file read on every clock cycle
•
no optional control lines
•
Execution:
•
Set RegDst:
select the Result register
•
Set ALUOp:
select the ALU operation
•
Set ALUSrc. 
select either Read data 2 or a sign-extended immediate for the ALU.
•
Memory access: 
•
Set Branch:
affects PCSrc
•
Set MemRead
•
Set MemWrite. 
•
Write back: 
•
Set MemtoReg:
decides between sending the ALU result or the memory value to the register file
•
Set Reg-Write:
specifies whether the register file can be written

Pipelined Control
RegDst
ALUSrc
ALUOp1
ALUOp0
Branch
MemRead
MemWrite
MemtoReg
Regwrite

Pipelined Control

Hazards
• Situations that prevent starting the next instruction in the 
next cycle
• Structure hazard
• A required resource is busy
• Data hazard
• Need to wait for previous instruction to complete its data read/write
• Control hazard
• Deciding on control action depends on previous instruction

Structure Hazards
• Conflict for use of a resource
• In MIPS pipeline with a single memory
• Load/store requires data access
• Instruction fetch would have to stall for that cycle
• Would cause a pipeline “bubble”
• Hence, pipelined datapaths require separate 
instruction/data memories
• Or separate instruction/data caches

Data Hazards
• An instruction depends on completion of data access by a 
previous instruction
• add$s0, $t0, $t1
• sub$t2, $s0, $t3

Forwarding (aka Bypassing)
• Use result when it is computed
• Don’t wait for 