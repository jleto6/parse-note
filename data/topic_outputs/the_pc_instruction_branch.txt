26 31 6 bits 26 bits Instruction Execution • For every instruction: 1. Send the program counter (PC) to the memory that contains the code and fetch the instruction from that memory. 1. Read one or two registers, using fields of the instruction to select the registers to read. For

---

Execution • Update PC: PC target address or PC + 4 • If the instruction is a branch, we have to calculate the target address • If the instruction is not a branch, the new PC will be PC + 4 Instruction Execution • Update PC: PC target address or

---

PC + 4 • If the instruction is a branch, we have to calculate the target address • If the instruction is not a branch, the new PC will be PC + 4 Instruction Execution • Execute: • Depending on instruction class, we use the ALU to calculate: • Arithmetic

---

if the constant is negative • Choose between the second read registers and the sign extended constant. Datapath: I-Type Instructions Load/Store Instructions • lw $t1, offset($t2) • sw $t1, offset($t2) • Compute memory address: $t2 + offset • Since offset is 16 bits, it needs to be extended to 32

---

Use ALU, subtract and check Zero output • Calculate target address • Sign-extend displacement • Shift left 2 places (word displacement) • Add to PC + 4 • Already calculated by instruction fetch Target Address Details • The base for the branch address calculation is the address of the instruction

---

following the branch. • PC+4 • Memory is byte addressed • The offset field must be shifted left 2 bits Branch Instructions Just re-routes wires Sign-bit wire replicated Branching beq $t1, $t2, offset • Branch is taken • When $t1 - $t2 = 0, the zero signal from the ALU

---

• PC = PC + 4 + 4*offset • Branch is not taken • PC = PC + 4 Datapath: Branch Jump Instructions • PC = PC[31-28] : Offset << 2 Single Datapath • All instructions executed in one clock cycle • Each datapath element can only do one function