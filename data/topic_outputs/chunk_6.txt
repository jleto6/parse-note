bits
op
rs
rt
immediate
0
16
21
26
31
6 bits
16 bits
5 bits
5 bits
op
target address
0
26
31
6 bits
26 bits

Instruction Execution
• For every instruction:
1.
Send the program counter (PC) to the memory that contains the 
code and fetch the instruction from that memory.
1.
Read one or two registers, using fields of the instruction to select 
the registers to read. For the load word instruction, we need to 
read only one register, but most other instructions require that we 
read two registers.

Instruction Execution
• Fetch:
• Get the next instruction: stored at PC

Instruction Execution
• Decode:
• Opcode determines if the instruction is arithmetic/logical, memory 
logical, or branch.

Instruction Execution
• Update PC:  PC target address or PC + 4
• If the instruction is a branch, we have to calculate the target 
address
• If the instruction is not a branch, the new PC will be PC + 4

Instruction Execution
• Update PC:  PC target address or PC + 4
• If the instruction is a branch, we have to calculate the target 
address
• If the instruction is not a branch, the new PC will be PC + 4

Instruction Execution
• Execute:
• Depending on instruction class, we use the ALU to calculate:
• Arithmetic result
• Memory address for load/store
• Branch target address

Instruction Execution
• To read and write registers, we need a register file
• R-types read two registers and write one register
• Memory-reference instructions read one register
• Also access data memory

Processor Overview
Data “flows” through 
memory and 
functional units

Processor Overview
Can’t just join 
wires together
Use multiplexers

Processor Overview
Multiplexers require 
selection signals 
Control Signals

Signals
• Information encoded in binary
• Low voltage = 0, High voltage = 1
• One wire per bit
• Multi-bit data encoded on multi-wire buses

Logic Design Review
• Combinational Circuits
• Output depends only on current input
• Operate on data
• Example: ALU
• Given the same input a combinational
circuit will always produce the same 
output

Logic Design Review
• Sequential Circuits
• Have “state”
• Output depends on current input and previous outputs
• Example: Register File
• Output depends on the contents
of the registers in the file

MIPS Register File
• 32 32-bit registers
• One write bus
• Two read buses
• Selection Inputs
• RegWrite (write enable signal) 
• Reg. Source A
• Reg. Source B
• Reg. Destination

Write Control Signals
Every Clock Cycle
• We do not show a write control 
signal when a state element is 
written on every active clock 
edge.
• Program Counter
When Necessary
• If a state element is not 
updated on every clock, then 
an explicit write control signal is 
required.
• Register File

Datapath Elements
• Most elements have 32-bit wide inputs and outputs 
• Buses labeled with their width

Datapath Elements - Combinational
I0
I1
Y
M
u
x
S
Multiplexer
Y = S ? I1 : I0
A
B
Y
+
A
B
Y
ALU
F
Adder
Y = A + B
Arithmetic/Logic Unit
Y = F(A, B)

Datapath Elements - Sequential

Fetch Elements
• Memory Unit
• Program Counter
• Adder

R-Type Instructions
• Read two register operands
• Perform arithmetic/logical operation
• Write register result

R-Type Instructions
add $t1, $t2, $t3
• RW = 9
• RA = 10
• RB = 11
• ALUop = “add”

Datapath: R-Type Instructions

I-Type Instructions
• Replace one read register, shamt, and funct with 16 bit 
constant
• ALU requires 32-bit inputs
• Sign-extend the 16 bit immediate
• Fill with 0s if the constant is positive
• Fill with 1s if the constant is negative
• Choose between the second read registers 
and the sign extended 