other instructions require that we 
read two registers.

Instruction Execution
• Fetch:
• Get the next instruction: stored at PC

Instruction Execution
• Decode:
• Opcode determines if the instruction is arithmetic/logical, memory 
logical, or branch.

Instruction Execution
• Update PC:  PC target address or PC + 4
• If the instruction is a branch, we have to calculate the target 
address
• If the instruction is not a branch, the new PC will be PC + 4

Instruction Execution
• Update PC:  PC target address or PC + 4
• If the instruction is a branch, we have to calculate the target 
address
• If the instruction is not a branch, the new PC will be PC + 4

Instruction Execution
• Execute:
• Depending on instruction class, we use the ALU to calculate:
• Arithmetic result
• Memory address for load/store
• Branch target address

Instruction Execution
• To read and write registers, we need a register file
• R-types read two registers and write one register
• Memory-reference instructions read one register
• Also access data memory

Processor Overview
Data “flows” through 
memory and 
functional units

Processor Overview
Can’t just join 
wires together
Use multiplexers

Processor Overview
Multiplexers require 
selection signals 
Control Signals

Signals
• Information encoded in binary
• Low voltage = 0, High voltage = 1
• One wire per bit
• Multi-bit data encoded on multi-wire buses

Logic Design Review
• Combinational Circuits
• Output depends only on current input
• Operate on data
• Example: ALU
• Given the same input a combinational
circuit will always produce the same 
output

Logic Design Review
• Sequential Circuits
• Have “state”
• Output depends on current input and previous outputs
• Example: Register File
• Output depends on the contents
of the registers in the file

MIPS Register File
• 32 32-bit registers
• One write bus
• Two read buses
• Selection Inputs
• RegWrite (write enable signal) 
• Reg. Source A
• Reg. Source B
• Reg. Destination

Write Control Signals
Every Clock Cycle
• We do not show a write control 
signal when a state element is 
written on every active clock 
edge.
• Program Counter
When Necessary
• If a state element is not 
updated on every clock, then 
an explicit write control signal is 
required.
• Register File

Datapath Elements
• Most elements have 32-bit wide inputs and outputs 
• Buses labeled with their width

Datapath Elements - Combinational
I0
I1
Y
M
u
x
S
Multiplexer
Y = S ? I1 : I0
A
B
Y
+
A
B
Y
ALU
F
Adder
Y = A + B
Arithmetic/Logic Unit
Y = F(A, B)

Datapath Elements - Sequential

Fetch Elements
• Memory Unit
• Program Counter
• Adder

R-Type Instructions
• Read two register operands
• Perform arithmetic/logical operation
• Write register result

R-Type Instructions
add $t1, $t2, $t3
• RW = 9
• RA = 10
• RB = 11
• ALUop = “add”

Datapath: R-Type Instructions

I-Type Instructions
• Replace one read register, shamt, and funct with 16 bit 
constant
• ALU requires 32-bit inputs
• Sign-extend the 16 bit immediate
• Fill with 0s if the constant is positive
• Fill with 1s if the constant is negative
• Choose between the second read registers 
and the sign extended constant.

Datapath: I-Type Instructions

Load/Store Instructions
• lw 
$t1, offset($t2)
• sw 
$t1, offset($t2)
• Compute memory address: $t2 + offset
• Since offset is 16 bits, it needs to be extended to 32 bits

Load/Store Instructions
• Load: Read memory and update register
• Store: Write register value to memory
• Elements: 
• Register file
• Sign extension unit
• Data memory unit

Datapath: Load Instruction

Datapath: Store Instruction

Branch Instructions
beq
$t1, $t2, offset
• 