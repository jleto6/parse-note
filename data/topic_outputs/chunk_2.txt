Branch: subtract
• R-type: depends on funct field
ALU Control
Function
0000
AND
0001
OR
0010
Add
0110
Subtract
0111
Set-on-less-than
1100
NOR

ALU Control
• Opcode determines which type of instruction
• The ALUOp is a 2-bit signal derived from this Opcode
• ALUOp and the funct field will determine ALU control
Opcode
ALUOp
Operation
Funct
ALU function
ALU Control
Lw
00
Load word
XXXXXX
Add
0010
Sw
00
Store word
XXXXXX
Add
0010
Beq
01
Branch
XXXXXX
Subtract
0110
R-type
10
Add
100000
Add
0010
Subtract
100010
Subtract
0110
AND
100100
AND
0000
OR
100101
OR
0001
Set-on-Less-
Than
101010
Set-on-Less-
Than
0111

ALU Control
• Multiple levels of decoding:
• Main Control generates ALUOp
• ALUOp and funct bits determine ALU Control

ALU Control
• ALUOp and funct bits determine ALU Control
ALUOp1
ALUOp2
Funct
Operation
0
0
X
X
X
X
X
X
0010 (add)
X
1
X
X
X
X
X
X
0110 (subtract)
1
X
X
X
0
0
0
0
0010 (add)
1
X
X
X
0
0
1
0
0110 (subtract)
1
X
X
X
0
1
0
0
0000 (and)
1
X
X
X
0
1
0
1
0001 (or)
1
X
X
X
1
0
1
0
0111 (slt)

The Main Control Unit
• Control signals derived from instruction
0
rs
rt
rd
shamt
funct
31:26
5:0
25:21
20:16
15:11
10:6
35 or 43
rs
rt
address
31:26
25:21
20:16
15:0
4
rs
rt
address
31:26
25:21
20:16
15:0
R-type
Load/
Store
Branch
opcode
always 
read
read, 
except 
for load
write for 
R-type 
and load
sign-extend 
and add

Main Control Unit
• Observations
• The opcode is always contained in bits 31:26. We will refer to this 
field as Op[5:0].
• The two registers to be read are always specified by the rs and rt 
fields, at positions 25:21 and 20:16. This is true for the R-type 
instructions, branch equal, and for store. 
• The base register for load and store instructions is always in bit 
positions 25:21 (rs). 
• The 16-bit offset for branch equal, load, and store is always in 
positions 15:0. 
• The destination register is in one of two places. 
• For a load it is in bit positions 20:16 (rt)
• For an R-type instruction it is in bit positions 15:11 (rd)
• We will need to add a multiplexor to select which field of the instruction is used 
to indicate the register number to be written.

Datapath with ALU Control

Control Signals – Register Destination
• RegDst
• Deasserted: the register destination number for the write register 
comes from the rt field (bits 20:16)
• Asserted: the register destination number for the write register 
comes from the rd field (bits 15:11)

Control Signals – Register Write
• RegWrite
• Asserted: the register destination specified by the write register 
input is written with the value from the write data input

Control Signals – ALU Source
• ALUSrc
• Deasserted: The second ALU operand comes from the second 
register file output
• Asserted: The second ALU operand is the sign-extended lower 16 
bits of the instruction

Control Signals - PCSrc
• Program Counter Source
• Deasserted: The PC is replaced by PC + 4
• Asserted: The PC is replaced by a branch target address

Control Signals – Memory Read
• MemRead
• Asserted: Data memory contents designated by the address input 
are put on the read data output.

Control Signals – Memory Write
• MemWrite
• Asserted: Data memory contents designated by the address input 
are replaced by the value on the write data input.

Control Signals – Memory to Register
• MemtoReg
• Deasserted: The value fed to the register write data input comes 
from the ALU
• Asserted: The value fed to the register write data input comes from 
the data memory.

Control Signals
• All but one signal can be set based only on the opcode
• PCSrc is the exception
• Relies on the result of a branch
• PCSrc should be set if the instruction is beq and the zero output of 
the ALU is asserted

Datapath With Control

Opcode to Control
Instruction
RegDst
ALUSrc
MemtoReg
RegWrite
R-Format
1
0
0
1
Lw
0
1
1
1
Sw
X
1
X
0
Beq
X
0
X
0
Instruction
MemRead
MemWrite
Branch
ALUOp1
ALUOp0
R-Format
0
0
0
1
0
Lw
1
0
0
0
0
Sw
0
1
0
0
0
Beq
0
0
1
0
1

R-Type Instruction

Load Instruction

Branch-on-Equal Instruction

Opcode to Control
In/Out 
Signal
R-Format
Lw
Sw
Beq
Inputs
Op5
0
1
1
0
Op4
0
0
0
0
Op3
0
0
1
0
Op2
0
0
0
1
Op1
0
1
1
0
Op0
0
1
1
0
Outputs
RegDst
1
0
X
X
ALUSrc
0
1
1
0
MemToReg
0
1
X
X
RegWrite
1
1
0
0
MemRead
0
1
0
0
MemWrite
0
0
1
0
Branch
0
0
0
1
ALUOp1
1
0
0
0
ALUOp0
0
0
0
1

Implementing Jumps
• Jump uses word address
• Update PC with concatenation of
• Top 4 bits of old PC
• 26-bit jump address
• 00
• 