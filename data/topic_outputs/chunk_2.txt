Direct mapped, 2-way set associative, fully associative
• Block access sequence: 0, 8, 0, 6, 8
• Direct mapped
• 5 misses
Block 
address
Cache 
index
Hit/miss
Cache content after access
0
1
2
3
0
0
miss
Mem[0]
8
0
miss
Mem[8]
0
0
miss
Mem[0]
6
2
miss
Mem[0]
Mem[6]
8
0
miss
Mem[8]
Mem[6]

Associativity Example
• Compare 4-block caches
• Direct mapped, 2-way set associative, fully associative
• Block access sequence: 0, 8, 0, 6, 8
• 2-way set associative
Block 
address
Cache 
index
Hit/miss
Cache content after access
Set 0
Set 1

Associativity Example
• Compare 4-block caches
• Direct mapped, 2-way set associative, fully associative
• Block access sequence: 0, 8, 0, 6, 8
• 2-way set associative
Block 
address
Cache 
index
Hit/miss
Cache content after access
Set 0
Set 1
0
0
miss
Mem[0]

Associativity Example
• Compare 4-block caches
• Direct mapped, 2-way set associative, fully associative
• Block access sequence: 0, 8, 0, 6, 8
• 2-way set associative
Block 
address
Cache 
index
Hit/miss
Cache content after access
Set 0
Set 1
0
0
miss
Mem[0]
8
0
miss
Mem[0]
Mem[8]

Associativity Example
• Compare 4-block caches
• Direct mapped, 2-way set associative, fully associative
• Block access sequence: 0, 8, 0, 6, 8
• 2-way set associative
Block 
address
Cache 
index
Hit/miss
Cache content after access
Set 0
Set 1
0
0
miss
Mem[0]
8
0
miss
Mem[0]
Mem[8]
0
0
hit
Mem[0]
Mem[8]

Associativity Example
• Compare 4-block caches
• Direct mapped, 2-way set associative, fully associative
• Block access sequence: 0, 8, 0, 6, 8
• 2-way set associative
Block 
address
Cache 
index
Hit/miss
Cache content after access
Set 0
Set 1
0
0
miss
Mem[0]
8
0
miss
Mem[0]
Mem[8]
0
0
hit
Mem[0]
Mem[8]
6
0
miss
Mem[0]
Mem[6]

Associativity Example
• Compare 4-block caches
• Direct mapped, 2-way set associative, fully associative
• Block access sequence: 0, 8, 0, 6, 8
• 2-way set associative
Block 
address
Cache 
index
Hit/miss
Cache content after access
Set 0
Set 1
0
0
miss
Mem[0]
8
0
miss
Mem[0]
Mem[8]
0
0
hit
Mem[0]
Mem[8]
6
0
miss
Mem[0]
Mem[6]
8
0
miss
Mem[8]
Mem[6]

Associativity Example
• Compare 4-block caches
• Direct mapped, 2-way set associative, fully associative
• Block access sequence: 0, 8, 0, 6, 8
• 2-way set associative
• 4 misses
Block 
address
Cache 
index
Hit/miss
Cache content after access
Set 0
Set 1
0
0
miss
Mem[0]
8
0
miss
Mem[0]
Mem[8]
0
0
hit
Mem[0]
Mem[8]
6
0
miss
Mem[0]
Mem[6]
8
0
miss
Mem[8]
Mem[6]

Associativity Example
• Compare 4-block caches
• Direct mapped, 2-way set associative, fully associative
• Block access sequence: 0, 8, 0, 6, 8
• Fully associative
• 3 misses
Block 
address
Hit/miss
Cache content after access
0
miss
Mem[0]
8
miss
Mem[0]
Mem[8]
0
hit
Mem[0]
Mem[8]
6
miss
Mem[0]
Mem[8]
Mem[6]
8
hit
Mem[0]
Mem[8]
Mem[6]

How Much Associativity
• Increased associativity decreases miss rate
• But with diminishing returns
• Simulation of a system with 64KB cache, 16-word blocks
• 1-way: 10.3%
• 2-way: 8.6%
• 4-way: 8.3%
• 8-way: 8.1%

Cache Write
• If we replace the data memory in our datapath with a cache, what happens on 
a store word instruction?
• If we wrote the data into only the data cache without changing main memory; 
then main memory would have a different value from that in the cache. 
• In such a case, the cache and memory are said to be inconsistent.

Write-Through
• Whenever changes are made to the data in the cache, also change 
the data in main memory.

Write-Through
• Whenever changes are made to the data in the cache, also change 
the data in main memory.
• Writes take longer
• Suppose 10% of instructions are stores and write to memory takes 100 
cycles
• If base CPI = 1, then effective CPI = 1 + 0.1×100 = 11

Write-Through
• Whenever changes are made to the data in the cache, also change 
the data in main memory.
• Writes take longer
• Solution: write buffer
• Holds data waiting to be written to memory
• CPU continues immediately
• Only stalls on write if write buffer is already full

Write-Back
• On data-write hit, just update the block in cache
• Keep track of whether each block is “clean” or “dirty”
• When a dirty block is replaced
• Write it back to memory
• Can use a write buffer to allow replacing block to be read first

Write Allocation
• What should happen 