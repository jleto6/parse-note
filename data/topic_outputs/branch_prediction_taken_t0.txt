avoid stalls by forwarding Pipeline Stalls • A stall (bubble) is implemented with a nop • “No operation” • Force control values in ID/EX register to 0 Stall/Bubble in the Pipeline Stall inserted here Another view (no bubble)... Stall inserted here Another view (with bubble)... Stall inserted here Code Scheduling

---

to Avoid Stalls • Reorder code to avoid use of load result in the next instruction • C code for A = B + E; C = B + F; lw $t1, 0($t0) lw $t2, 4($t0) add $t3, $t1, $t2 sw $t3, 12($t0) lw $t4, 8($t0) add $t5, $t1, $t4

---

sw $t5, 16($t0) stall stall lw $t1, 0($t0) lw $t2, 4($t0) lw $t4, 8($t0) add $t3, $t1, $t2 sw $t3, 12($t0) add $t5, $t1, $t4 sw $t5, 16($t0) 11 cycles 13 cycles Control Hazards • Branch Hazards • Branch determines flow of control • Fetching next instruction depends on branch

---

outcome • Pipeline can’t always fetch correct instruction • Still working on ID stage of branch Stall on Branch • Wait until branch outcome determined before fetching next instruction Branch Prediction • Longer pipelines can’t readily determine branch outcome early • Stall penalty becomes unacceptable • Predict outcome of branch

---

• Only stall if prediction is wrong • In MIPS pipeline • Can predict branches not taken • Fetch instruction after branch, with no delay Predict Branch Not Taken • If branch is determined as taken in MEM: PC Flush these instructions (Set control values to 0) Predict Branch Not

---

Taken Prediction correct Prediction incorrect Predict Branch Not Taken • If branches are untaken half the time, and if it costs little to discard the instructions, this optimization halves the cost of control hazards. Branch Prediction • Static branch prediction • Based on typical branch behavior • Example: loop and

---

if-statement branches • Predict backward branches taken • Predict forward branches not taken Dynamic Branch Prediction • In deeper and superscalar pipelines, branch penalty is more significant • Use dynamic prediction • Branch History Table • Indexed by recent branch instruction addresses • Stores outcome (taken/not taken) • To execute

---

a branch • Check table, expect the same outcome • Start fetching from fall-through or target • If wrong, flush pipeline and flip prediction 1-Bit Predictor: Shortcoming • Inner loop branches mispredicted twice! outer: … … inner: … … beq …, …, inner … beq …, …, outer Mispredict as

---

taken on last iteration of inner loop Then mispredict as not taken on first iteration of inner loop next time around 2-Bit Predictor • Only change prediction on two successive mispredictions Delayed Decision • Branch Instruction • Execute the next sequential instruction • Execute the instruction that resulted from the

---

branch • add $4, $5, $6 -> beq $1, $2, 40 • beq $1, $2, 40 -> add $4, $5, $6 • <branch result> <branch result> Cycle Time Matters • Delayed branches work when branches are short • no processor uses a delayed branch of more than 1 cycle •

---

Longer branch delays rely on hardware based branch prediction Reducing Branch Delay • Insight: • many branches rely only on simple tests • can be implemented with a few gates over an ALU • more complex branches take two instructions • slt followed by beq/bne • Move hardware to determine

---

a stall in the pipeline Cache Miss (Instruction Memory) 1. Send the original PC value (current PC – 4) to the memory. 2. Instruct main memory to perform a read and wait for the memory to complete its access. 3. Write the cache entry, putting the data from memory in