each instruction) does not decrease
• Programs execute billions of instructions – throughput is important!

Pipelining and ISA Design
• MIPS ISA designed for pipelining
• All instructions are 32-bits
• Easier to fetch and decode
• Few and regular instruction formats
• Can decode and read registers in one step
• Load/store addressing
• Can calculate address in 3rd stage, access memory in 4th stage
• Alignment of memory operands
• Memory access takes only one cycle

MIPS Pipelined Datapath
WB
Branch

Pipelined Execution

Pipeline registers
• Need registers between stages
• To hold information produced in previous cycle

IF for Load

ID for Load

EX for Load

MEM for Load

WB for Load
Wrong
register
number

Corrected Datapath for Load

Pipelined Control

Pipelined Control
•
Instruction fetch: 
•
PC written on every clock cycle
•
Instruction memory read on every clock cycle
•
no optional control lines
•
Instruction decode/register file read
•
Register file read on every clock cycle
•
no optional control lines
•
Execution:
•
Set RegDst:
select the Result register
•
Set ALUOp:
select the ALU operation
•
Set ALUSrc. 
select either Read data 2 or a sign-extended immediate for the ALU.
•
Memory access: 
•
Set Branch:
affects PCSrc
•
Set MemRead
•
Set MemWrite. 
•
Write back: 
•
Set MemtoReg:
decides between sending the ALU result or the memory value to the register file
•
Set Reg-Write:
specifies whether the register file can be written

Pipelined Control
RegDst
ALUSrc
ALUOp1
ALUOp0
Branch
MemRead
MemWrite
MemtoReg
Regwrite

Pipelined Control

Hazards
• Situations that prevent starting the next instruction in the 
next cycle
• Structure hazard
• A required resource is busy
• Data hazard
• Need to wait for previous instruction to complete its data read/write
• Control hazard
• Deciding on control action depends on previous instruction

Structure Hazards
• Conflict for use of a resource
• In MIPS pipeline with a single memory
• Load/store requires data access
• Instruction fetch would have to stall for that cycle
• Would cause a pipeline “bubble”
• Hence, pipelined datapaths require separate 
instruction/data memories
• Or separate instruction/data caches

Data Hazards
• An instruction depends on completion of data access by a 
previous instruction
• add$s0, $t0, $t1
• sub$t2, $s0, $t3

Forwarding (aka Bypassing)
• Use result when it is computed
• Don’t wait for it to be stored in a register
• Requires extra connections in the datapath

Forwarding
• Forwarding: the result is passed forward from an earlier 
instruction to a later instruction.

Load-Use Data Hazard
• Can’t always avoid stalls by forwarding

Pipeline Stalls
• A stall (bubble) is implemented with a nop
• “No operation”
• Force control values in ID/EX register to 0

Stall/Bubble in the Pipeline
Stall inserted 
here

Another view (no bubble)...
Stall inserted 
here

Another view (with bubble)...
Stall inserted 
here

Code Scheduling to Avoid Stalls
• Reorder code to avoid use of load result in the next 
instruction
• C code for A = B + E; C = B + F;
lw
$t1, 0($t0)
lw
$t2, 4($t0)
add $t3, $t1, $t2
sw
$t3, 12($t0)
lw
$t4, 8($t0)
add $t5, $t1, $t4
sw
$t5, 16($t0)
stall
stall
lw
$t1, 0($t0)
lw
$t2, 4($t0)
lw
$t4, 8($t0)
add $t3, $t1, $t2
sw
$t3, 12($t0)
add $t5, $t1, $t4
sw
$t5, 16($t0)
11 cycles
13 cycles

Control Hazards
• Branch Hazards
• Branch determines flow of control
• Fetching next instruction depends on branch outcome
• Pipeline can’t always fetch correct instruction
• Still working on ID stage of branch

Stall on Branch
• Wait until branch outcome determined before fetching 
next instruction

Branch Prediction
• Longer pipelines can’t readily determine branch outcome 
early
• Stall penalty becomes unacceptable
• Predict outcome of branch
• Only stall if prediction is wrong
• In MIPS pipeline
• Can predict branches not taken
• Fetch instruction after branch, with no delay

Predict Branch Not Taken
• If branch is determined as 