MEMORY
Memory Hierarchy: Caches

Introduction
• An ideal computing system has unlimited fast memory
• Obviously, this is not possible
• A memory hierarchy gives the illusion of large amounts of fast memory

Principle of Locality
• Programs access only a small proportion of their address space at any time
• Temporal locality
• Items accessed recently are likely to be accessed again soon
• e.g., instructions in a loop, induction variables
• Spatial locality
• Items near those accessed recently are likely to be accessed soon
• E.g., sequential instruction access, array data

Memory Hierarchy
• Smaller, faster memory is closer to the processor

Caches
• Permanent storage on disk
• Copy recently accessed and nearby items from disk to smaller DRAM memory
• Main memory
• Copy recently accessed and nearby items from DRAM to smaller SRAM 
memory
• Cache memory attached to CPU
• Cache may also refer to any storage that takes advantage of locality

Memory Hierarchy Levels
• Block: unit of copying
• May be multiple words
• If accessed data is present in 
upper level
• Hit: access satisfied by upper level
• Hit ratio: hits/accesses
• If accessed data is absent
• Miss: block copied from lower level
• Time taken: miss penalty
• Miss ratio: misses/accesses
= 1 – hit ratio
• Then accessed data supplied from 
upper level

Cache Memory
• Cache memory
• The level of the memory hierarchy closest to the CPU
• Given accesses X1, …, Xn–1, Xn
How do we know if 
the data is present?
Where do we look?

Direct Mapped Cache
• Each word can go in exactly one place in the cache
• Assign a location based on the address of the word
• (Block address) modulo (#Blocks in cache)

Direct Mapped Cache
• Each word can go in exactly one place in the cache
• Assign a location based on the address of the word
• (Block address) modulo (#Blocks in cache)

Direct Mapped Cache
• Each word can go in exactly one place in the cache
• Assign a location based on the address of the word
• (Block address) modulo (#Blocks in cache)
#Blocks is a 
power of 2
Use low-order 
address bits

Tags and Valid Bits
• How do we know which particular block is stored in a cache location?
• Store block address as well as the data
• Only need the high-order bits
• Called the tag
• What if there is no data in a location?
• Valid bit: 1 = present, 0 = not present
• Initially 0

Cache Read
• Reads are simpler because reads do not change the contents of the cache
• Example:
• 8-Block, Direct Mapped Cache
• Addresses:
• Binary
Decimal
Cache Block (address mod 8)
• 10110
22
110
• 11010
26
010
• 10110
22
110
• 11010
26
010
• 10000
16
000
• 00011
3
011
• 10000
16
000
• 10010
18
010
• 10000
16
000

Cache Example
• Initial state
Index
V
Tag
Data
000
N
001
N
010
N
011
N
100
N
101
N
110
N
111
N

Cache Example
Index
V
Tag
Data
000
N
001
N
010
N
011
N
100
N
101
N
110
Y
10
Mem[10110]
111
N
Word addr
Binary addr
Hit/miss
Cache block
22
10 110
Miss
110

Cache Example
Index
V
Tag
Data
000
N
001
N
010
Y
11
Mem[11010]
011
N
100
N
101
N
110
Y
10
Mem[10110]
111
N
Word addr
Binary addr
Hit/miss
Cache block
26
11 010
Miss
010

Cache Example
Index
V
Tag
Data
000
N
001
N
010
Y
11
Mem[11010]
011
N
100
N
101
N
110
Y
10
Mem[10110]
111
N
Word addr
Binary addr
Hit/miss
Cache block
22
10 110
Hit
110
26
11 010
Hit
010

Cache Example
Index
V
Tag
Data
000
Y
10
Mem[10000]
001
N
010
Y
11
Mem[11010]
011
Y
00
Mem[00011]
100
N
101
N
110
Y
10
Mem[10110]
111
N
Word addr
Binary addr
Hit/miss
Cache block
16
10 000
Miss
000
3
00 011
Miss
011
16
10 000
Hit
000

Cache Example
Index
V
Tag
Data
000
Y
10
Mem[10000]
001
N
010
Y
10
Mem[10010]
011
Y
00
Mem[00011]
100
N
101
N
110
Y
10
Mem[10110]
111
N
Word addr
Binary addr
Hit/miss
Cache block
18
10 010
Miss
010

Address Subdivision

Cache Hit
• Index of the address specifies cache block
• If the valid bit indicates data is present, check the tags
• If the tags match, it is a hit
• We can use the data stored in the cache 
• CPU proceeds normally

Cache Misses
• If the valid bit is not set or if the tags do not match, it is a miss
• Control unit must detect and 