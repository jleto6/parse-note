those improvements are to load • Violates the design principle of making the common case fast • Some functional units must be duplicated, increasing hardware cost Pipelining • Pipelining is an implementation technique in which multiple instructions are overlapped in execution. • Pipelining is nearly universal. Analogy for Pipelining: Laundry

---

all the stages take about the same amount of time and there is enough work to do, then the speedup due to pipelining is roughly equal to the number of stages in the pipeline. • Laundry Analogy: • 4 stages (washing, drying, folding, putting away) • 20 loads pipelined would

---

data memory. 1. Write the result into a register. • Instruction Fetch (IF) • Instruction Decode (ID) • Execution (EX) • Memory Access (MEM) • Write Back (WB) Pipeline Speedup • If all stages are balanced • i.e., all take the same time • Time between instructionspipelined = Time between

---

instructionsnonpipelined Number of stages • If not balanced, speedup is less • Speedup due to increased throughput • Latency (time for each instruction) does not decrease • Programs execute billions of instructions – throughput is important! Pipelining and ISA Design • MIPS ISA designed for pipelining • All instructions are

---

Pipelined Datapath WB Branch Pipelined Execution Pipeline registers • Need registers between stages • To hold information produced in previous cycle IF for Load ID for Load EX for Load MEM for Load WB for Load Wrong register number Corrected Datapath for Load Pipelined Control Pipelined Control • Instruction fetch:

---

fetch would have to stall for that cycle • Would cause a pipeline “bubble” • Hence, pipelined datapaths require separate instruction/data memories • Or separate instruction/data caches Data Hazards • An instruction depends on completion of data access by a previous instruction • add$s0, $t0, $t1 • sub$t2, $s0, $t3

---

outcome to ID stage • Target address adder • Register comparator • Reduces the penalty of a branch to only one instruction if the branch is taken Summary • Pipelining improves performance by increasing instruction throughput • Executes multiple instructions in parallel • Each instruction has the same latency •

---

data hazards • Pipelining is independent of technology • So why haven’t we always done pipelining? • More transistors make more advanced techniques feasible • Pipeline-related ISA design needs to take account of technology trends Pitfalls • Poor ISA design can make pipelining harder • e.g., complex instruction sets (VAX,

---

IA-32) • Significant overhead to make pipelining work • e.g., complex addressing modes • Register update side effects, memory indirection • e.g., delayed branches • Advanced pipelines have long delay slots Concluding Remarks • ISA influences design of datapath and control • Datapath and control influence design of ISA •

---

Pipelining improves instruction throughput • More instructions completed per second • Latency for each instruction not reduced • Hazards: structural, data, control • Exceptions are handled by a outside handler and control hazard logic. MEMORY Memory Hierarchy: Caches Introduction • An ideal computing system has unlimited fast memory • Obviously,