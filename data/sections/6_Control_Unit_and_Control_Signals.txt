<h1>Datapath Elements and Control for MIPS I-Type, Load/Store, Branch, and Related Instructions</h1>
<p style="color:whitesmoke;">
<strong>I-Type Instructions</strong> extend the basic MIPS instruction set by incorporating immediate values in arithmetic and logical operations, providing a direct means for the processor to handle constants and address calculations efficiently. The format uses a 16-bit <strong>immediate</strong> field, which often requires sign extension for further processing.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
<strong>Datapath: I-Type Instructions</strong> leverage the immediate value, extracted from the <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">instruction[15:0]</code> field. A <strong>sign extension unit</strong> converts the 16-bit value into a 32-bit constant, ensuring compatibility with the 32-bit ALU input. A multiplexer controlled by the <strong>ALUSrc</strong> signal determines whether the ALU secondary input is the sign-extended immediate value or the content of a source register (for R-type operations). This arrangement enables the ALU to compute the required operation, such as addition or comparison, with one operand potentially being a constant.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
<strong>Load/Store Instructions</strong> in the MIPS subset use the <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">lw</code> (load word) and <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">sw</code> (store word) forms: 
<code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">lw $t1, offset($t2)</code> or <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">sw $t1, offset($t2)</code>. The <strong>memory address</strong> is computed by the ALU as the sum of register <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">$t2</code> (base) and the sign-extended 16-bit <strong>offset</strong>. This addition allows for efficient translation of address calculations for both load and store instructions.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
The <strong>offset</strong> field's 16-bit width cannot accommodate a 32-bit address directly, requiring a <strong>sign extension unit</strong> to convert the offset to 32 bits, preserving the sign of the value in two's-complement form if negative. The <strong>ALU</strong> receives the base register and the sign-extended offset, computes their sum, and generates the effective address for memory access.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
In <strong>Load Instructions</strong>, once the effective address is produced by the ALU, the <strong>register file</strong> provides the base register, the <strong>sign extension unit</strong> delivers the offset, and the <strong>data memory unit</strong> provides access to the memory location. Data returned from memory is routed, via another multiplexer, to the register file to update the destination register.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
For <strong>Store Instructions</strong>, the computed address allows data from the register file (the value in the specified source register) to be sent to the <strong>data memory unit</strong>, which stores the data at the calculated location. Both load and store datapaths require precise control over the memory and register elements, orchestrated by control signals governing read (`MemRead`), write (`MemWrite`), register file writes, and multiplexer selections.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
<strong>Branch Instructions</strong> like <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">beq $t1, $t2, offset</code> use register operands compared by the ALU, which performs a subtraction and sets a <strong>Zero</strong> signal if the operands are equal (<code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">$t1 - $t2 == 0</code>). If the Zero output is high, the branch is taken. The branch target address calculation uses a sign-extended and left-shifted (by 2 bits) displacement, which is then added to the next instruction address (<code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">PC + 4</code>), previously determined during instruction fetch. This design exploits instruction alignment to optimize calculation.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
The <strong>Target Address Details</strong> are essential: the base is always the address of the instruction following the branch (<code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">PC+4</code>), since MIPS memory is byte-addressed, but the offset encodes words, necessitating that the 16-bit offset be shifted left two positions before being added to <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">PC+4</code>. This ensures that branching operates on full-word boundaries within instruction memory.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
The <strong>Branch Instruction Datapath</strong> mainly re-routes wires using multiplexers and duplication of the sign-bit (for sign-extension), reflecting that no arithmetic except subtraction and address calculation is required. If the comparison yields Zero, the branch address is selected as the next <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">PC</code> value; otherwise, sequential execution continues.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
<strong>Branching Control:</strong> For <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">beq $t1, $t2, offset</code>, the branch is taken if <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">$t1-$t2=0</code>, using the Zero output. The control logic then sets <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">PC=PC+4+4*offset</code>; if not taken, the default incremented <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">PC=PC+4</code> is used.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
<strong>Datapath: Branch</strong> instructions primarily control program flow, rather than data computation, relying on the ALU Zero signal and address calculation logic to select the next instruction address.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
<strong>Jump Instructions</strong>, such as <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">j target</code>, modify the <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">PC</code> by directly concatenating the top four bits of the current <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">PC</code> value with the (shifted left by 2) 26-bit target address field. This mechanism allows large, aligned jumps within the instruction memory by constructing a pseudo-direct address using current <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">PC[31:28]</code> and the target field.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
A <strong>Single Datapath</strong> architecture executes all instructions in a single clock cycle. No datapath element can be shared concurrently; any element required for multiple phases within the same cycle must be duplicated. This necessitates separate <strong>instruction memory</strong> and <strong>data memory</strong> units in the design. Multiplexers are pervasive wherever alternate data sources flow to shared hardware, requiring precise control signal selection to route operands and results according to instruction type.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
The <strong>Control Unit</strong> is responsible for:
<ul>
  <li>Receiving the input instruction</li>
  <li>Generating write signals for each state element updated only conditionally</li>
  <li>Driving the selection signals for every multiplexer</li>
  <li>Producing function and control signals for the ALU (<code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">ALUOp</code> and derived signals)</li>
</ul>
This centralizes coordination of the datapath and adapts its function dynamically to each instruction.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
<strong>ALU Control</strong> in this MIPS subset governs ALU function according to instruction:
<ul>
  <li>Load/Store instructions: use <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">add</code> (function code <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">0010</code>) to compute memory addresses</li>
  <li>Branch instructions: use <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">subtract</code> (function code <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">0110</code>) to compare register values</li>
  <li>R-type instructions: the function (<code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">funct</code>) field determines the desired operation</li>
</ul>
The ALU control mapping for basic operations is:
<ul>
  <li><strong>0000</strong>: AND</li>
  <li><strong>0001</strong>: OR</li>
  <li><strong>0010</strong>: Add</li>
  <li><strong>0110</strong>: Subtract</li>
  <li><strong>0111</strong>: Set-on-less-than</li>
  <li><strong>1100</strong>: NOR</li>
</ul>
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
Opcode fields determine if an instruction is load/store, branch, or R-type. A two-bit <strong>ALUOp</strong> signal, produced by the main control logic in response to the opcode, directs ALU function selection. For <strong>R-type</strong> instructions, further decoding uses the <strong>funct</strong> field (6 bits) in conjunction with <strong>ALUOp</strong>:
<ul>
  <li><strong>Lw/Sw</strong>: <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">ALUOp=00</code>, ALU function = add (<code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">0010</code>)</li>
  <li><strong>Beq</strong>: <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">ALUOp=01</code>, ALU function = subtract (<code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">0110</code>)</li>
  <li><strong>R-type</strong>: <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">ALUOp=10</code>, ALU function determined by <strong>funct</strong> field</li>
</ul>
The ultimate ALU control signal may be generated via a combinational logic table, ensuring only valid functions according to the instruction class.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
The ALU control process is hierarchical:
<ol>
  <li>The main control unit decodes the instruction's <strong>opcode</strong> to generate an <strong>ALUOp</strong> field.</li>
  <li><strong>ALUOp</strong> and/or <strong>funct</strong> fields further select one of 16 basic ALU functions through combinational logic.</li>
</ol>
This division supports flexible expansion of ALU functionality without modifying the top-level control logic.
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
The <strong>Main Control Unit</strong> analyzes decoder outputs—specifically, the opcode (bits 31:26, or <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">Op[5:0]</code>)—to set all required control signals for the datapath:
<ul>
  <li>Register read signals (always read <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">rs</code> and <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">rt</code> for R-type, <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">beq</code>, and <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">sw</code>; only <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">rs</code> for <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">lw</code>)</li>
  <li>Register file write enables (write for R-type and load, not for store or branch)</li>
  <li>Sign-extension activation for offset/immediate values</li>
  <li>Multiplexor signals, such as source of register destination number, source for ALU operands, and data memory enables</li>
</ul>
</p>
<!-- END_SECTION -->

<p style="color:whitesmoke;">
Control signal setup for determining the <strong>Register Destination</strong> field must resolve whether the destination register address comes from bits 20:16 (<strong>rt</strong>, for <code style="color:#00aaff; font-family: Menlo, Monaco, 'Courier New', monospace;">lw</code>) or bits 15:11 (<strong>rd</strong>, for R-type). A dedicated multiplexer, controlled by a <strong>RegDst</strong> signal from the main control unit, selects which field updates the register file destination address. This mechanism is crucial for correctly handling destination selection across instruction formats.
</p>
<!-- END_SECTION -->