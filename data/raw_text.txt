**Transcription of Handwritten Notes:**

---

**Binary Conversions**

In the modern world, we use decimal, or base 10, notation to represent integers. We can represent numbers using any base b, where b is a positive integer greater than 1.

**Base 10**:  
When we write 965, this can be translated as : 9·10^2 + 6·10^1 + 5·10^0

**Base b**:  
- let b be a positive integer greater than 1. Then if n is a positive integer, it can be expressed uniquely in the form, where k is a nonnegative integer and a_k,a_(k-1),...,a_0 are nonnegative integers less than b.  
This expression of n is called the base b expansion of n and can be denoted by a_k a_(k-1)... a_0 b

**Binary Expansions**  
Computers represent integers and do arithmetic with binary (base 2) expansions of integers. In these expansions, the digits are 0 and 1.  
Example: What is the decimal expansion of the integer that has (11011)2 as its binary expansion?  
Solution: (11011)2  
= 1·2^4 + 1·2^3 + 0·2^2 + 1·2^1 + 1·2^0  
= 16 + 8 + 0 + 2 + 1  
= 27

**Base Conversion**:  
- To construct the base b expansion of the integer n, divide n by b to obtain a quotient and remainder: n = bq_0 + a_0, 0 ≤ a_0 < b.  
The remainder, a_0, is the rightmost digit in the base b expansion of n.  
Next divide q_0 by b to get: q_0 = bq_1 + a_1, 0 ≤ a_1 < b.  
Continue until the quotient is 0.  
The base b expansion of n is then the digits a_k a_(k-1)... a_2 a_1 a_0, where a_k is the leftmost digit and a_0 is the rightmost digit. This is the base b expansion of n.  
Continue by successively dividing the quotient by b, obtaining the remainder as the next digit, and the new quotient to divide.  
Obtaining the sequence of digits as the remainder. The process terminates when the quotient is 0.

---
Introduction MIPS ISA 3 Instruction Types R-type, I-type, J-type » Datapath and Control Unit Simplified Pipelined Simple subset » Memory reference: Iw, sw Arithmetic/logical: add, addi, sub, and, or, slit Control transfer: j

Instruction Format Review Three instruction formats 6 6 Retype [ rs [ rt funct_| 48 5 bits, 5 Sbits Sbits 6     » Sbits 16 bits J-type 4 re 6 bits 26 bits » Fields: op: operation of the instruction » rs, rt, rd: source/destination register specifiers shamt: shift amount » funct: selects variant of the operation in the “op” field address/immediate: address offset or immediate value target address: target address of the jump instruction

MIPS Subset Add, Subtract, AND, OR, SLT » add rd, rs, rt       rt 31 26 21 16 1 6 0 and rs rt rd 6bits Sbits 6 bits orrd, rs, rt sitrd, rs, rt ADD Immediate addi rt, rs, imm16 31 26 21 16 0 + Load, Store T rs [ rt | immediate rs, imm16 6bits 16 bits swrt, rs, imm16 » BRANCH » beqrs, rt, imm16 31 26 0 JUMP: op target address target 6 bits 26 bits

