COMPUTER 
ARITHMETIC

Background Information
• Binary Numbers
• 2’s Complement representation
• Addition
• Subtraction
• Arithmetic Logic Unit
• Contains Adders to perform addition and subtraction

Integer Multiplication
• “Paper and pencil” example
Multiplicand
1000
Multiplier
x 1001
1000
0000
0000
Shift after each step
+ 1000   
Product
01001000

Combinational Multiplier
• Partial product accumulation 
A0
B0
A0 B0
A1
B1
A1 B0
A0 B1
A2
B2
A2 B0
A1 B1
A0 B2
A3
B3
A3 B0
A2 B1
A1 B2
A0 B3
A3 B1
A2 B2
A1 B3
A3 B2
A2 B3
A3 B3
S6
S5
S4
S3
S2
S1
S0
S7

Combinational Multiplier
• Partial product accumulation
Note use of parallel carry-outs to form higher order sums
12 Adders, if full adders, this is 6 gates each = 72 gates
16 gates form the partial products
total = 88 gates
A 0 B 0 
A 1  B 0 
A 0 B 1 
A 0 B 2 
A 1 B 1 
A 2 B 0 
A 0 B 3 
A 1 B 2 
A 2 B 1 
A 3 B 0 
A 1 B 3 
A 2 B 2 
A 3 B 1 
A 2 B 3 
A 3 B 2 
A 3 B 3 
HA 
S 0 
S 1 
HA 
F A 
F A 
S 3 
F A 
F A 
S 4 
HA 
F A 
S 2 
F A 
F A 
S 5 
F A 
S 6 
HA 
S 7

Integer Multiplication
• “Paper and pencil” example
Multiplicand
1000
Multiplier
x 1001
1000
0000
0000
Shift after each step
+ 1000   
Product
01001000

Observations
• Number of bits in the product is larger than the number in 
either the multiplicand or the multiplier. 
• m bits x n bits = m+n bit product
• Overflow is a possible issue
• Binary rules – “choices”
0 => place 0 
( 0 x multiplicand)
1 => place a copy  
( 1 x multiplicand)
• 3 versions of unsigned multiplication hardware
• successive refinement

Multiplication 
• Insight from paper and pencil algorithm
• Shift the multiplicand left one digit each step 
• With 32 steps in a 32-bit number, we move 32 bits to the left
• Requires a 64-bit register
• Place 32 zeroes in the left half (unoccupied half)
• Unsigned numbers do not require sign extension
• Multiplicand will be added to the sum in the product register
• Product register will also be 64 bits
• Requires a 64 bit ALU to add

Multiplication Hardware Version 1
• 64-bit Multiplicand reg, 64-bit ALU, 64-bit Product reg, 32-
bit multiplier reg
64-bit ALU
Control test
Multiplier
Shift right
Product
Write
Multiplicand
Shift left
64 bits
64 bits
32 bits
Figure 3.3 from text

Multiplication 
Algorithm Version 1
Done
Done
1. Test
Multiplier0
1a. Add multiplicand to product and
place the result in Product register
2. Shift the Multiplicand register left 1 bit
3. Shift the Multiplier register right 1 bit
32nd repetition?
Start
Multiplier0 = 0
Multiplier0 = 1
No: < 32 repetitions
Yes: 32 repetitions
Figure 3.4 from text

Multiplication Example (11x9)
Iter.
Step Product
Multiplicand
Multiplier
Action
0
0
00000000
00001011
1001
Initialize
1
1a.
00001011
00001011
1001
Add
1
2,3
00001011
00010110
0100
Shifts
2
1
00001011
00010110
0100
Test-no add
2
2,3
00001011
00101100
0010
Shifts
3
1
00001011
00101100
0010 
Test-no add
3
2,3 
00001011 01011000
0001
Shifts
4
1a.
01100011
01011000
0001
Add
4
2,3
01100011
10110000 
0000
Shifts

Multiplication is Time Consuming
• 3 steps per iteration
• 32 iterations
• 96 steps total

Observations on Multiplication Version 1
• Half the bits of the multiplicand are always 0
• 64-bit adder is wasted
• 0’s inserted in right of multiplicand as shifted
• LSBs of product never changed once formed
• Instead of shifting the multiplicand to the left we can shift 
the product to the right
• Perform some steps in parallel

Multiplication Hardware Version 2
• 32-bit Multiplicand reg, 32 -bit ALU, 64-bit Product reg, 
32-bit Multiplier reg
Multiplier
Shift right
Write
32 bits
64 bits
32 bits
Shift right
Multiplicand
32-bit ALU
Product
Control test
Figure from a previous version of the text

Multiplication 
Algorithm 
Version 2
Done
Yes: 32 repetitions
Done
1. Test
Multiplier0
1a. Add multiplicand to the left half of
the product and place the result in
the left half of the Product register
2. Shift the Product register right 1 bit
3. Shift the Multiplier register right 1 bit
32nd repetition?
Start
Multiplier0 = 0
Multiplier0 = 1
No: < 32 repetitions
Yes: 32 repetitions
Figure from a previous version of the text

Multiplication Example (11x9)
Iter.
Step Product
Multiplicand
Multiplier
Action
0
0
00000000
1011
1001
Initialize

Multiplication Example (11x9)
Iter.
Step Product
Multiplicand
Multiplier
Action
0
0
00000000
1011
1001
Initialize
Test the LSB of multiplier
1 indicates Add

Multiplication Example (11x9)
Iter.
Step Product
Multiplicand
Multiplier
Action
0
0
00000000
1011
1001
Initialize
1001
Add
Add the left half of the product 
to the multiplicand.  Store in 
left half of product.

Multiplication Example (11x9)
Iter.
Step Product
Multiplicand
Multiplier
Action
0
0
00000000
1011
1001
Initialize
1
1a.
10110000
1011
1001
Add
Add the left half of the product 
to the multiplicand.  Store in 
left half of product.

Multiplication Example (11x9)
Iter.
Step Product
Multiplicand
Multiplier
Action
0
0
00000000
1011
1001
Initialize
1
1a.
10110000
1011
1001
Add
Shift both the product and the 
multiplier to the right.

Multiplication Example (11x9)
Iter.
Step Product
Multiplicand
Multiplier
Action
0
0
00000000
1011
1001
Initialize
1
1a.
10110000
1011
1001
Add
1
2, 3
01011000
1011
0100
Shifts
Shift both the product and the 
multiplier to the right.

Multiplication Example (11x9)
Iter.
Step Product
Multiplicand
Multiplier
Action
0
0
00000000
1011
1001
Initialize
1
1a.
10110000
1011
1001
Add
1
2,3
01011000
1011
0100
Shifts
2
1
01011000
1011
0100
Test-no add
2
2,3
00101100
1011
0010
Shifts
3
1
00101100
1011
0010 
Test-no add
3
2,3 
00010110 1011
0001
Shifts
4
1a.
11000110
1011 
0001
Add
4
2,3
01100011
1011  
0000
Shifts

Multiplication 
Algorithm 
Version 2
Observation
Product register 
wastes space 
(lower half = 0)
Exactly equal to the 
size of multiplier left
We can combine 
Multiplier register 
and Product register
Done
Yes: 32 repetitions
Done
1. Test
Multiplier0
1a. Add multiplicand to the left half of
the product and place the result in
the left half of the Product register
2. Shift the Product register right 1 bit
3. Shift the Multiplier register right 1 bit
32nd repetition?
Start
Multiplier0 = 0
Multiplier0 = 1
No: < 32 repetitions
Yes: 32 repetitions
Figure from a previous version of the text

Multiplication Hardware Version 3
• 32-bit Multiplicand reg, 32-bit ALU, 64-bit Product reg, (no 
Multiplier reg)
Control 
test
Write
32 bits
64 bits
Shift right
Product
Multiplicand
32-bit ALU
Figure 3.5 from text

Done
Multiplication 
Algorithm 
Version 3
Done
1. Test
Product0
1a. Add multiplicand to the left half of
the product and place the result in
the left half of the Product register
2. Shift the Product register right 1 bit
32nd repetition?
Start
Product0 = 0
Product0 = 1
No: < 32 repetitions
Yes: 32 repetitions
Figure from a previous version of the text

Multiplication Example (11x9)
Iter.
Step Product
Multiplicand
Action
0
0
0000 1001
1011
Initialize
1
1a.
1011 1001
1011 
Add
1 
2
0101 1100
1011 
Shift
2 
1
0101 1100
1011 
Test-no add
2
2
0010 1110
1011 
Shift
3 
1
0010 1110
1011 
Test-no add
3 
2 
0001 0111
1011 
Shift
4
1a.
1100 0111
1011 
Add
4
2
0110 0011 
1011 
Shift 
Note: Multiplier in Product Register is underlined

Multiplying by a Constant
• Some compilers replace multiplies by short constants with 
a series of shifts and adds. Because one bit to the left 
represents a number twice as large in base 2, shifting the 
bits left has the same effect as multiplying by a power of 
2. 
• Almost every compiler will perform the strength reduction 
optimization of substituting a left shift for a multiply by a 
power of 2.

Multiplying by a Constant
• Some compilers replace multiplies by short constants with 
a series of shifts and adds. Because one bit to the left 
represents a number twice as large in base 2, shifting the 
bits left has the same effect as multiplying by a power of 
2. 
• Almost every compiler will perform the strength reduction 
optimization of substituting a left shift for a multiply by a 
power of 2.
• 4 * 2 = 8
• 0100 * 0010 = 1000
• 0100 << 1 = 1000

Multiplying by a Constant
• Some compilers replace multiplies by short constants with 
a series of shifts and adds. Because one bit to the left 
represents a number twice as large in base 2, shifting the 
bits left has the same effect as multiplying by a power of 
2. 
• Almost every compiler will perform the strength reduction 
optimization of substituting a left shift for a multiply by a 
power of 2.
• 2 * 4 = 8
• 0010 * 0100 = 1000
• 0010 << 2 = 1000

Signed Multiplication
• So far, we have multiplied unsigned numbers
• What about signed multiplication?
• one solution: make both positive
• leave out the sign bit, run for 31 steps
• set sign bit negative if signs of inputs differ

Booth’s Algorithm
• multiply two’s complement signed numbers 
• uses same hardware as before
• can also be used to reduce the number of steps

Insight for Booth’s Algorithm
• Example: 2 x 6 = 0010 x 0110:
0010
x
0110
+
0000
shift (0 in multiplier)
+
0010 
add (1 in multiplier)
+
0010
add (1 in multiplier)
+ 0000   
shift (0 in multiplier)
00001100
• ALU can get same result in more than one way:
• 6 x = 4x + 2x or 6x = – 2x + 8 x
• 111 = 1000 – 0001
• 1111 = 10000 – 00001
• 1111XXX = 10000XXX – 00001XXX

Insight for Booth’s Algorithm 
• Replace string of 1s in multiplier with
• initially subtract when we see first 1 (from right)
• later, add when we see 0 at left end of the string of 1s.
• Example
0010
x
0110
+
0000
shift (0 in multiplier)
-
0010 
subtract (first 1 in string)
+
0000
shift (within string of 1s)
+
0010   
add (end of string)
00001100
• Effectively: 2 x 6 = 2 x 8 – 2 x 2

Booth’s Algorithm
Current
Right
Explanation
Example
1
0
Beginning of a run of 1s
0001111000
1
1
Middle of a run of 1s
0001111000
0
1
End of a run of 1s
0001111000
0
0
Middle of a run of 0s
0001111000
0 1 1 1 1 0
beginning of run
end of run
middle of run

Booth’s Algorithm
1. Depending on the current and previous bits, do one of 
the following:
00: Middle of a string of 0s, so no arithmetic operations.
01: End of a string of 1s, so add the multiplicand to the left half of 
the product.
10: Beginning of a string of 1s, so subtract the multiplicand from 
the left half of the product.
11: Middle of a string of 1s, so no arithmetic operation.
2. As in the previous algorithm, shift the Product register 
right (arithmetic shift) 1 bit.

Booth’s Example (-5 x -6)
• Multiplicand = –6 = 1010; –Multiplicand = 6 = 0110
• Multiplier = –5 = 1011
Iter.
Step
Product
Last
Action
0
0
0000 101(1 0)
0
Initialize
1
1.10
0110 101(1 0) 
0 
Start string: Subtract => Add 0110
1 
2
0011 010(1 1) 
1 
Shift arithmetic
2 
1.11
0011 010(1 1) 
1 
Middle string: nothing
2
2
0001 101(0 1) 
1 
Shift arithmetic
3 
1.01
1011 101(0 1) 
1
End string: add 1010
3 
2 
1101 110(1 0) 
0 
Shift arithmetic
4
1.10
0011 110(1 0) 
0 
Start string: Subtract => add 0110
4
2
0001 1110
1 
Shift arithmetic 
Notes: 1. Multiplier in Product Register is underlined.
2. Current/previous bits are in parentheses.
3. Previous bit is initialized to 0

Booth’s Algorithm
• Originally for speed: Shifts are faster than add
• Key advantage today: Works properly for 2’s complement 
numbers without requiring special fix for sign!

Division: Paper and Pencil
• “Paper and pencil” example
• 20 ÷ 6 = 3 Remainder 2
00011
Quotient
110 10100 
Dividend
10
101
1010
-
110_
1000
-
110
10
Remainder
Dividend = Quotient * Divisor + Remainder
Divisor

Division: Paper and Pencil
• “Paper and pencil” example
• 20 ÷ 6 = 3 Remainder 2
00011
Quotient
110 10100 
Dividend
10
101
1010
-
110_
1000
-
110
10
Remainder
Divisor
Algorithm:
If Partial Remainder > Divisor
then Quotient bit = 1; 
Remainder = Remainder – Divisor
else Quotient bit = 0 
Shift down next dividend bit

Division Hardware
• Same as Multiplication Hardware!
• 32-bit Divisor reg, 32 -bit ALU, 64-bit Remainder reg
• Dividend stored in remainder register, Quotient formed in remainder register
Write
32 bits
64 bits
Shift left
Shift right
Remainder
32-bit ALU
Divisor
Control
test
Figure 3.11 from text

Division 
Algorithm
Start
Done. Shift left half of Remainder right 1 bit
Test Remainder
3a. Shift the Remainder register to the
left, setting the new rightmost bit to 1
32nd repetition?
Start
Remainder < 0
No: < 32 repetitions
Yes: 32 repetitions
3b. Restore the original value by adding
the Divisor register to the left half of the
Remainder register and place the sum
in the left half of the Remainder register.
Also shift the Remainder register to the
left, setting the new rightmost bit to 0
2. Subtract the Divisor register from the
left half of the Remainder register and
place the result in the left half of the
Remainder register
Remainder
0
1. Place Dividend in Remainder register.
Shift the Remainder register left 1 bit
–>
Figure from a previous 
version of the text
Takes n Steps for
n-bit Quotient and 
Remainder

Division Example
• Example: 14 ÷ 3 = 4; remainder 2. 
Iter Step Remainder
Divisor
Action
0
0
0001 1100
0011
Initialize
1
1
1110 1100
0011 
Subtract: Remainder<0
1
2b.
0011 1000 
0011
Restore; shift in 0
2
1
0000 1000
0011
Subtract; Remainder=0
2
2a.
0001 0001 
0011
Shift in a 1
3
1
1110 0001
0011 
Subtract: Remainder<0
3
2b.
0010 0010 
0011 
Restore; shift in 0
4
1
1111 0010
0011 
Subtract: Remainder<0
4
2b.
0100 0100 
0011 
Restore; shift in 0
3
0010 0100
0011
Shift remainder right
Rem. Quot.

Observations on Division Hardware
• Same Hardware as Multiply: just need ALU to add or 
subtract, and 64-bit register to shift left or shift right
• Hi and Lo registers in MIPS combine to act as 64-bit 
register for multiply and divide

Signed Division
• Store the signs of the divisor and dividend
• Convert divisor and dividend to positive
• Complement quotient and remainder if necessary
• Dividend and Remainder are defined to have same sign
• Quotient negated if Divisor sign and Dividend sign disagree

Beyond Integers
• Real numbers
• Called “float” values
• Computer arithmetic that supports real numbers is called 
floating point arithmetic

Exponential Notation
• The following are equivalent representations of 1,234
The representations differ in that 
the decimal place – the “point” --
“floats” to the left or right (with 
the appropriate adjustment in the 
exponent).
123,400.0    x 10-2
12,340.0    x 10-1
1,234.0    x 100
123.4    x 101
12.34   x 102
1.234  x 103
0.1234 x 104

Standards
• Floats are implemented using the IEEE 754 standard
• found in virtually every computer invented since 1980 
• has greatly improved both the ease of porting floating-point 
programs and the quality of computer arithmetic.
• IEEE 754 was created to:
• Simplify exchange of data that includes floating-point numbers 
• Simplify the floating-point arithmetic algorithms 
• Increases the accuracy of the numbers that can be stored
• Increased accuracy due to normalized scientific notation

Normalized Scientific Notation
• A number in scientific notation that has no leading 0s is 
called a normalized number.  
• 1.0ten * 10–9 is in normalized scientific notation
• 0.1ten * 10–8 is not normalized
• 10.0ten * 10–10 is not in scientific notation

Floating Point: Scientific Notation
• Number represented as 
•
Mantissa
•
Radix (base)
•
Exponent
In a binary number, the radix (or base) is 2 instead of 10.  
The general form could be written as 1.xxxxxx * 2yyyyy. 
6.02 x 10
23
exponent
radix (base)
Mantissa
decimal point
Sign
magnitude
Sign
magnitude

Floating Point: Normalized Scientific Notation
• The mantissa must be normalized: 1.xxxxxx * 2yyyyy
• Always has a 1 in front of the binary point
• This 1 does not need to be stored
• Floating point numbers have an implied “1” on left of the 
decimal place
• Mantissa 10100000000000000000000
• Represents 1.1012 = 1.62510

IEEE 754 Standard
• Single precision: 32 bits, consisting of...
• Sign bit (1 bit)
• Exponent (8 bits)
• Mantissa (23 bits) 
sign
1
8
23
exponent
fraction
Normalized binary significand with 
hidden bit (1):  1.M
S
E
M

IEEE 754 Standard
• Single precision: 32 bits, consisting of...
• Sign bit (1 bit)
• Exponent (8 bits)
• Mantissa (23 bits) 
• Fractions almost as small as 2.0ten * 10–38
• Numbers almost as large as 2.0ten * 1038
• Overflow may still occur
• Exponent is too large to be represented 
• Underflow may occur
• Exponent is too small to be represented

IEEE 754 Standard
• Single precision: 32 bits, consisting of...
• Sign bit (1 bit)
• Exponent (8 bits)
• Mantissa (23 bits) 
• Double precision: 64 bits, consisting of…
• Sign bit (1 bit)
• Exponent (11 bits)
• Mantissa (52 bits)
sign S
1
11
52
exponent
fraction
Normalized binary significand 
with hidden bit (1):  1.M
E
M

Normalization
• General form for floating-point numbers: (–1)S * (1+M) * 2E
• How do we represent zero? 
• E = 0
• M = 0

Excess Notation
• To include positive (+ve) and negative (–ve) 
exponents, “excess” notation is used 
• Also called biased notation
• Represents the most negative exponent as 
0...0two and the most positive exponent as 1…1two. 
Single Precision (8-bit Exponent): 00000000 – 11111111 (0-255)
00000000
= -127
11111111
= 128
01111111
= 0

Excess Notation
• The value of the exponent stored is larger than 
the actual exponent
• Single precision:  excess 127
• Double precision: excess 1023
• Each real number is 
(–1)S * (1 + Fraction) * 2(Exponent – Bias)
• E.g., excess 127,
• Exponent 
• Represents…
10000111
135 – 127 = 8

Example
• Single precision
0 10000010 11000000000000000000000
1.112
130 – 127 = 3
0 = positive mantissa
+1.112 x 23 = 1110.02 = 14.010

Converting from Floating Point
• What decimal value is represented by the following 32-bit 
floating point number?
1100 0001 0111 1011 0000 
0000 0000 00002

Converting from Floating Point
•Step 1: find S, E, and M
1   10000010     111101100000000000000002
S
E
M
1 = negative
0 = positive

Converting from Floating Point
•Step 2: Find “real” exponent, n
• n
= E – 127
= 100000102 – 127
= 130 – 127
= 3

Converting from Floating Point
• Step 3: Put S, M, and n together to form 
binary result
• Don’t forget the implied “1.” on the left of the 
mantissa.
-1.11110112 x 2n =
-1.11110112 x 23 =
-1111.10112

Converting from Floating Point
•Step 4: Express result in decimal
-1111.10112
-15
2-1 = 0.5
2-3 = 0.125
2-4 = 0.0625
0.6875
Answer: -15.6875

Converting to Floating Point
•Express 36.562510 as a 32-bit floating 
point number

Converting to Floating Point
•Step 1: Express original value in 
binary
36.562510 =   100100.10012
36 = 2 * 18 + 0
18 = 2 * 9   + 0
9   = 2 * 4   + 1
4   = 2 * 2   + 0
2   = 2 * 1   + 0
1   = 2 * 0   + 1
.5625 * 2 = 1.125
.125   * 2 = 0.25
.25     * 2 = 0.5
.5       * 2 = 1.0 
.0       * 2 = 0.0
.0       * 2 = 0.0
.0       * 2 = 0.0

Converting to Floating Point
•Step 2: Normalize
100100.10012 =   1.0010010012 x 25

Converting to Floating Point
•Step 3: Determine S, E, and M
+1.0010010012 x 25
S = 0 (because the value is positive)
M
S
n
E = n + 127
= 5 + 127
= 132
= 100001002

Converting to Floating Point
•Step 4: Put S, E, and M together to 
form 32-bit binary result
0 10000100 001001001000000000000002
S
E
M

Special Values
• Single Precision: Exponents of 0 and 255 have special 
meaning
• E=0, M=0 represents 0 (sign bit still used so there is +/-0)
• E=0, M≠0 is a denormalised number (+/-0.Mx2-126) (smaller than 
the smallest normalised number)
• E=255, M=0 represents +/- infinity
• E=255, M ≠ 0 represents NaN (not a number, e.g., returned for 0/0 
or sqrt(-1))
Exponent
Significand
Value
0
0
0
0
nonzero
denormalized number
1..emax-1
anything
normal floating point number
emax
0
infinity
emax
nonzero
Not a Number (NaN)

Floating Point Operations
• Arithmetic:
• multiplication, division: 
• multiply/divide mantissa
• add/subtract exponent
• example: 5.6x1011 x 6.7x1012 = 5.6 x 6.7 x 1023
• Addition, subtraction
• convert operands to have the same exponent value
• add/subtract mantissas
• example: 2.1x103 + 4.3x104 = 0.21 x 104 + 4.3 x 104

Basic Addition Algorithm
1. Align binary points (denormalize smaller number)
a. compute Diff = Exp(Y) – Exp (X); 
b. Sig(X) = Sig(X) >> Diff  
c. Exp = Exp(Y)
2. Add the aligned components
• Sig = Sig (x) + Sig (Y)
3. Normalize the sum
• Shift Sig right/left until leading bit is 1; decrementing 
or incrementing Exp.
• Check for overflow in Exp
• Round (needs more bits, as we will see)
• repeat step 3 if not still normalized

Basic 
Addition 
Algorithm

Addition Example
11.0 + 6.0, 4-bit mantissa
1.0110 x 23 + 1.1000 x 22
1. Align binary points (denormalize smaller number)
1.0110 x 23
+0.1100 x 23
2. Add the aligned components
10.0010 x 23 (=17) 
3. Normalize the sum
1.0001 x 24
• No overflow, no rounding

Basic Multiplication Algorithm
1.
Compute exponents
• Multiplication: Exp = Exp (X) + Exp (Y) – bias;
• Division: Exp = Exp (X) – Exp(Y) + bias;
2.
Multiply/Divide significands
• Multiplication: Sig = Sig (X) x Sig (Y);
• Division: Sig = Sig(X) / Sig(Y);
3. Normalize the product
• Shift Sig right until leading bit is 1; incrementing Exp.
• Check for overflow in Exp
• repeat step 3 if not still normalized
4.
Round
• Any bits that do not fit must be discarded
5.
Set sign
• positive if signs same; negative if signs differ

Basic 
Multiplication 
Algorithm

Multiplication Example
.5 * -.4375, 4-bit mantissa
1.0000two * 2–1 * – 1.1100two * 2–2
1.
Compute exponents
-1 + (-2) = -3
With Bias: 126 + 125 – 127 = 124
2.
Multiply/Divide significands
0111000000
3.
Normalize the product
1.11000000 * 2–3
4.
Round
1.1100 * 2–3
5.
Set sign
-1.1100 * 2–3 because original signs differ

Multiplication Example
.5 * -.4375, 4-bit mantissa
1.0000two * 2–1 * – 1.1100two * 2–2
1.
Compute exponents
-1 + (-2) = -3
2.
Multiply/Divide significands
0111000000
3.
Normalize the product
1.11000000 * 2–3
4.
Round
1.1100 * 2–3
5.
Set sign
-1.1100 * 2–3 because original signs differ
11100
x 10000
00000
00000
00000
00000
11100         
111000000

Accuracy and Rounding
• Floating-point numbers are approximations for a number 
they can’t really represent. 
• Infinite possible real numbers between 0 and 1
• We can only represent 253 of them
• Approximate by rounding

Rounding Modes
• IEEE Standard has five rounding modes:   
• round to nearest, ties to even (default)
• round to nearest, ties away from zero
• round towards plus infinity
• round towards minus infinity
• round towards 0

Rounding Hardware
• To round accurately, we need the hardware to include 
extra bits for the calculation.
• Specifically, we keep 2 extra bits on the right
• Guard bit
• Round bit

Guard Bit
• The first bit to the right: an additional digit (bit) used in 
intermediate calculations to prevent loss of accuracy.

Example for Guard Bit
8.5 – 3.75 = 4.75, 4-bit mantissa
1.0001x23 – 1.1110x21
1.
Align binary point:
1.0001 x 23
-0.0111 x 23
2.
Subtract the aligned components:
0.1010 x 23 
3.
Normalize:
1.0100 x 22
Note our answer is actually 5.  With only 4-bits we are losing accuracy.  
Our result would be off by 0.25 or a whole bit in the least significant 
place.

Example for Guard Bit
8.5 – 3.75 = 4.75, 4-bit mantissa
1.0001x23 – 1.1110x21
1. Align binary point:
1.0001    x 23
-0.01111
x 23
g
2. Subtract the aligned components:
0.10011
x 23
g
3. Normalize:
1.0011 x 22
Now our normalized value is accurate
1.0011 x 22 = 4.75

Round Bit
• Bit to the right of guard bit needed for accurate rounding.

Example for Round Bit
• Example: 1.0000 x 20 - 1.0001 x 2–2
• guard and round bits shown
1.0000 x 20
- 0.010001 x 20
0.101111 x 20
Result
1.01111 x 2-1
Normalize
1.1000 x 2-1
Round; simple round up
• Without round bit, result is 1.0111

Sticky Bit
• Round to nearest problems
• need to know if actual result is closer to the next rounded value up 
or the next rounded value down.
• With 4-bit significand, a result of 1.11011 could round to 1.1101 if 
rounding down or 1.1110 if rounding up
• Potentially need a much greater number of bits
• Instead keep “sticky” bit (S):
• used to determine whether there are any 1 bits truncated below the 
guard and round bits
• S=1 if any bits are off to the right, otherwise S=0

Example for Sticky Bit
• 1.0000 x 20 + 1.0001 x 2–5
• guard, round, and sticky bits shown
1.0000 x 20
+ 0.000010 x 20 1
1.000010 x 20 1
Result
1.0001 x 20
Round to nearest
Without S rounds to 1.0000.

Exceptions
• Invalid operation
• result of operation is a NaN (except = or !=)
• inf. +/- inf.;  0 * inf;  0/0;  inf./inf.;  x remainder y, y = 0;
• sqrt(x) where x < 0, x = +/- inf.
• Overflow
• result of operation is larger than largest representable 
number
• flushed to +/- inf. if overflow exception is not enabled

Exceptions
• Divide by 0
• x/0 where x = 0, +/- inf.;  
• flushed to +/- inf. if divide by zero exception not enabled
• Underflow
• subnormal result OR non-zero result underflows to 0
• Inexact
• rounded result not the actual result (rounding error = 0)

Exceptions
• IEEE Standard specifies defaults and allows traps to 
permit exceptions to be handled at the program level
• contrast with the more usual result of aborting the 
computation altogether.

Datapath   Ad       Read                           register 1 n           ALU operation                 sn ata 1 8 | sign- | 22 MemRead      

PROCESSOR 
DATAPATH

Introduction
• MIPS ISA
• 3 Instruction Types
• R-type, I-type, J-type
• Datapath and Control Unit
• Simplified
• Pipelined
• Simple subset
• Memory reference: lw, sw
• Arithmetic/logical: 
add, addi, sub, and, or, slt
• Control transfer: 
beq, j

Instruction Format Review
• Three  instruction formats
• R-type
• I-type
• J-type
• Fields:
• op: operation of the instruction
• rs, rt, rd: source/destination register specifiers
• shamt: shift amount
• funct: selects variant of the operation in the “op” field
• address/immediate: address offset or immediate value
• target address: target address of the jump instruction 
op
target address
0
26
31
6 bits
26 bits
op
rs
rt
rd
shamt
funct
0
6
11
16
21
26
31
6 bits
6 bits
5 bits
5 bits
5 bits
5 bits
op
rs
rt
immediate
0
16
21
26
31
6 bits
16 bits
5 bits
5 bits

MIPS Subset
• Add, Subtract, AND, OR, SLT
• add rd, rs, rt
• sub rd, rs, rt
• and rd, rs, rt
• or rd, rs, rt
• slt rd, rs, rt
• ADD Immediate
• addi  rt, rs, imm16
• Load, Store
• lw rt, rs, imm16
• sw rt, rs, imm16
• BRANCH
• beq rs, rt, imm16
• JUMP:
• j  target
op
rs
rt
rd
shamt
funct
0
6
11
16
21
26
31
6 bits
6 bits
5 bits
5 bits
5 bits
5 bits
op
rs
rt
immediate
0
16
21
26
31
6 bits
16 bits
5 bits
5 bits
op
target address
0
26
31
6 bits
26 bits

Instruction Execution
• For every instruction:
1.
Send the program counter (PC) to the memory that contains the 
code and fetch the instruction from that memory.
1.
Read one or two registers, using fields of the instruction to select 
the registers to read. For the load word instruction, we need to 
read only one register, but most other instructions require that we 
read two registers.

Instruction Execution
• Fetch:
• Get the next instruction: stored at PC

Instruction Execution
• Decode:
• Opcode determines if the instruction is arithmetic/logical, memory 
logical, or branch.

Instruction Execution
• Update PC:  PC target address or PC + 4
• If the instruction is a branch, we have to calculate the target 
address
• If the instruction is not a branch, the new PC will be PC + 4

Instruction Execution
• Update PC:  PC target address or PC + 4
• If the instruction is a branch, we have to calculate the target 
address
• If the instruction is not a branch, the new PC will be PC + 4

Instruction Execution
• Execute:
• Depending on instruction class, we use the ALU to calculate:
• Arithmetic result
• Memory address for load/store
• Branch target address

Instruction Execution
• To read and write registers, we need a register file
• R-types read two registers and write one register
• Memory-reference instructions read one register
• Also access data memory

Processor Overview
Data “flows” through 
memory and 
functional units

Processor Overview
Can’t just join 
wires together
Use multiplexers

Processor Overview
Multiplexers require 
selection signals 
Control Signals

Signals
• Information encoded in binary
• Low voltage = 0, High voltage = 1
• One wire per bit
• Multi-bit data encoded on multi-wire buses

Logic Design Review
• Combinational Circuits
• Output depends only on current input
• Operate on data
• Example: ALU
• Given the same input a combinational
circuit will always produce the same 
output

Logic Design Review
• Sequential Circuits
• Have “state”
• Output depends on current input and previous outputs
• Example: Register File
• Output depends on the contents
of the registers in the file

MIPS Register File
• 32 32-bit registers
• One write bus
• Two read buses
• Selection Inputs
• RegWrite (write enable signal) 
• Reg. Source A
• Reg. Source B
• Reg. Destination

Write Control Signals
Every Clock Cycle
• We do not show a write control 
signal when a state element is 
written on every active clock 
edge.
• Program Counter
When Necessary
• If a state element is not 
updated on every clock, then 
an explicit write control signal is 
required.
• Register File

Datapath Elements
• Most elements have 32-bit wide inputs and outputs 
• Buses labeled with their width

Datapath Elements - Combinational
I0
I1
Y
M
u
x
S
Multiplexer
Y = S ? I1 : I0
A
B
Y
+
A
B
Y
ALU
F
Adder
Y = A + B
Arithmetic/Logic Unit
Y = F(A, B)

Datapath Elements - Sequential

Fetch Elements
• Memory Unit
• Program Counter
• Adder

R-Type Instructions
• Read two register operands
• Perform arithmetic/logical operation
• Write register result

R-Type Instructions
add $t1, $t2, $t3
• RW = 9
• RA = 10
• RB = 11
• ALUop = “add”

Datapath: R-Type Instructions

I-Type Instructions
• Replace one read register, shamt, and funct with 16 bit 
constant
• ALU requires 32-bit inputs
• Sign-extend the 16 bit immediate
• Fill with 0s if the constant is positive
• Fill with 1s if the constant is negative
• Choose between the second read registers 
and the sign extended constant.

Datapath: I-Type Instructions

Load/Store Instructions
• lw 
$t1, offset($t2)
• sw 
$t1, offset($t2)
• Compute memory address: $t2 + offset
• Since offset is 16 bits, it needs to be extended to 32 bits

Load/Store Instructions
• Load: Read memory and update register
• Store: Write register value to memory
• Elements: 
• Register file
• Sign extension unit
• Data memory unit

Datapath: Load Instruction

Datapath: Store Instruction

Branch Instructions
beq
$t1, $t2, offset
• Read register operands
• Compare operands
• Use ALU, subtract and check Zero output
• Calculate target address
• Sign-extend displacement
• Shift left 2 places (word displacement)
• Add to PC + 4
• Already calculated by instruction fetch

Target Address Details
• The base for the branch address calculation is the 
address of the instruction following the branch. 
• PC+4
• Memory is byte addressed 
• The offset field must be shifted left 2 bits

Branch Instructions
Just
re-routes 
wires
Sign-bit wire 
replicated

Branching
beq
$t1, $t2, offset
• Branch is taken
• When $t1 - $t2 = 0, the zero signal from the ALU
• PC = PC + 4 + 4*offset
• Branch is not taken
• PC = PC + 4

Datapath: Branch

Jump Instructions
• PC = PC[31-28] : Offset << 2

Single Datapath
• All instructions executed in one clock cycle
• Each datapath element can only do one function at a time
• Any element needed more than once must be duplicated
• Hence, we need separate instruction and data memories
• Use multiplexers where alternate data sources are used 
for different instructions

