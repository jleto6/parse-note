Introduction MIPS ISA 3 Instruction Types R-type, I-type, J-type » Datapath and Control Unit Simplified Pipelined Simple subset » Memory reference: Iw, sw Arithmetic/logical: add, addi, sub, and, or, slit Control transfer: j

Instruction Format Review Three instruction formats 6 6 Retype [ rs [ rt funct_| 48 5 bits, 5 Sbits Sbits 6     » Sbits 16 bits J-type 4 re 6 bits 26 bits » Fields: op: operation of the instruction » rs, rt, rd: source/destination register specifiers shamt: shift amount » funct: selects variant of the operation in the “op” field address/immediate: address offset or immediate value target address: target address of the jump instruction

MIPS Subset Add, Subtract, AND, OR, SLT » add rd, rs, rt       rt 31 26 21 16 1 6 0 and rs rt rd 6bits Sbits 6 bits orrd, rs, rt sitrd, rs, rt ADD Immediate addi rt, rs, imm16 31 26 21 16 0 + Load, Store T rs [ rt | immediate rs, imm16 6bits 16 bits swrt, rs, imm16 » BRANCH » beqrs, rt, imm16 31 26 0 JUMP: op target address target 6 bits 26 bits

Datapath   Ad       Read                           register 1 n           ALU operation                 sn ata 1 8 | sign- | 22 MemRead      

PROCESSOR 
DATAPATH

Introduction
• MIPS ISA
• 3 Instruction Types
• R-type, I-type, J-type
• Datapath and Control Unit
• Simplified
• Pipelined
• Simple subset
• Memory reference: lw, sw
• Arithmetic/logical: 
add, addi, sub, and, or, slt
• Control transfer: 
beq, j

Instruction Format Review
• Three  instruction formats
• R-type
• I-type
• J-type
• Fields:
• op: operation of the instruction
• rs, rt, rd: source/destination register specifiers
• shamt: shift amount
• funct: selects variant of the operation in the “op” field
• address/immediate: address offset or immediate value
• target address: target address of the jump instruction 
op
target address
0
26
31
6 bits
26 bits
op
rs
rt
rd
shamt
funct
0
6
11
16
21
26
31
6 bits
6 bits
5 bits
5 bits
5 bits
5 bits
op
rs
rt
immediate
0
16
21
26
31
6 bits
16 bits
5 bits
5 bits

MIPS Subset
• Add, Subtract, AND, OR, SLT
• add rd, rs, rt
• sub rd, rs, rt
• and rd, rs, rt
• or rd, rs, rt
• slt rd, rs, rt
• ADD Immediate
• addi  rt, rs, imm16
• Load, Store
• lw rt, rs, imm16
• sw rt, rs, imm16
• BRANCH
• beq rs, rt, imm16
• JUMP:
• j  target
op
rs
rt
rd
shamt
funct
0
6
11
16
21
26
31
6 bits
6 bits
5 bits
5 bits
5 bits
5 bits
op
rs
rt
immediate
0
16
21
26
31
6 bits
16 bits
5 bits
5 bits
op
target address
0
26
31
6 bits
26 bits

Instruction Execution
• For every instruction:
1.
Send the program counter (PC) to the memory that contains the 
code and fetch the instruction from that memory.
1.
Read one or two registers, using fields of the instruction to select 
the registers to read. For the load word instruction, we need to 
read only one register, but most other instructions require that we 
read two registers.

Instruction Execution
• Fetch:
• Get the next instruction: stored at PC

Instruction Execution
• Decode:
• Opcode determines if the instruction is arithmetic/logical, memory 
logical, or branch.

Instruction Execution
• Update PC:  PC target address or PC + 4
• If the instruction is a branch, we have to calculate the target 
address
• If the instruction is not a branch, the new PC will be PC + 4

Instruction Execution
• Update PC:  PC target address or PC + 4
• If the instruction is a branch, we have to calculate the target 
address
• If the instruction is not a branch, the new PC will be PC + 4

Instruction Execution
• Execute:
• Depending on instruction class, we use the ALU to calculate:
• Arithmetic result
• Memory address for load/store
• Branch target address

Instruction Execution
• To read and write registers, we need a register file
• R-types read two registers and write one register
• Memory-reference instructions read one register
• Also access data memory

Processor Overview
Data “flows” through 
memory and 
functional units

Processor Overview
Can’t just join 
wires together
Use multiplexers

Processor Overview
Multiplexers require 
selection signals 
Control Signals

Signals
• Information encoded in binary
• Low voltage = 0, High voltage = 1
• One wire per bit
• Multi-bit data encoded on multi-wire buses

Logic Design Review
• Combinational Circuits
• Output depends only on current input
• Operate on data
• Example: ALU
• Given the same input a combinational
circuit will always produce the same 
output

Logic Design Review
• Sequential Circuits
• Have “state”
• Output depends on current input and previous outputs
• Example: Register File
• Output depends on the contents
of the registers in the file

MIPS Register File
• 32 32-bit registers
• One write bus
• Two read buses
• Selection Inputs
• RegWrite (write enable signal) 
• Reg. Source A
• Reg. Source B
• Reg. Destination

Write Control Signals
Every Clock Cycle
• We do not show a write control 
signal when a state element is 
written on every active clock 
edge.
• Program Counter
When Necessary
• If a state element is not 
updated on every clock, then 
an explicit write control signal is 
required.
• Register File

Datapath Elements
• Most elements have 32-bit wide inputs and outputs 
• Buses labeled with their width

Datapath Elements - Combinational
I0
I1
Y
M
u
x
S
Multiplexer
Y = S ? I1 : I0
A
B
Y
+
A
B
Y
ALU
F
Adder
Y = A + B
Arithmetic/Logic Unit
Y = F(A, B)

Datapath Elements - Sequential

Fetch Elements
• Memory Unit
• Program Counter
• Adder

R-Type Instructions
• Read two register operands
• Perform arithmetic/logical operation
• Write register result

R-Type Instructions
add $t1, $t2, $t3
• RW = 9
• RA = 10
• RB = 11
• ALUop = “add”

Datapath: R-Type Instructions

I-Type Instructions
• Replace one read register, shamt, and funct with 16 bit 
constant
• ALU requires 32-bit inputs
• Sign-extend the 16 bit immediate
• Fill with 0s if the constant is positive
• Fill with 1s if the constant is negative
• Choose between the second read registers 
and the sign extended constant.

Datapath: I-Type Instructions

Load/Store Instructions
• lw 
$t1, offset($t2)
• sw 
$t1, offset($t2)
• Compute memory address: $t2 + offset
• Since offset is 16 bits, it needs to be extended to 32 bits

Load/Store Instructions
• Load: Read memory and update register
• Store: Write register value to memory
• Elements: 
• Register file
• Sign extension unit
• Data memory unit

Datapath: Load Instruction

Datapath: Store Instruction

Branch Instructions
beq
$t1, $t2, offset
• Read register operands
• Compare operands
• Use ALU, subtract and check Zero output
• Calculate target address
• Sign-extend displacement
• Shift left 2 places (word displacement)
• Add to PC + 4
• Already calculated by instruction fetch

Target Address Details
• The base for the branch address calculation is the 
address of the instruction following the branch. 
• PC+4
• Memory is byte addressed 
• The offset field must be shifted left 2 bits

Branch Instructions
Just
re-routes 
wires
Sign-bit wire 
replicated

Branching
beq
$t1, $t2, offset
• Branch is taken
• When $t1 - $t2 = 0, the zero signal from the ALU
• PC = PC + 4 + 4*offset
• Branch is not taken
• PC = PC + 4

Datapath: Branch

Jump Instructions
• PC = PC[31-28] : Offset << 2

Single Datapath
• All instructions executed in one clock cycle
• Each datapath element can only do one function at a time
• Any element needed more than once must be duplicated
• Hence, we need separate instruction and data memories
• Use multiplexers where alternate data sources are used 
for different instructions

